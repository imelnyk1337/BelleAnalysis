from typing import List, Dictclass CutsManager:    _initial_cuts_dict = None    _current_cuts_dict = None    _previous_cuts_dict = None    _number_of_instances = 0    def __init__(self) -> None:        self._cuts_split = []        CutsManager._number_of_instances += 1    @property    def cuts(self) -> List[str]:        return self._cuts_split    @cuts.setter    def cuts(self, new_cut: str):        self._cuts_split.append(new_cut)    @cuts.deleter    def cuts(self):        self._cuts_split.clear()    @classmethod    def init(cls, dict_like: Dict[str, List[float]]):        cls._initial_cuts_dict = dict_like        cls._current_cuts_dict = cls._initial_cuts_dict    @classmethod    def update(cls, dict_like: Dict[str, List[float]]) -> None:        cls._previous_cuts_dict = cls._current_cuts_dict        cls._current_cuts_dict = dict_like    @staticmethod    def __merge_cuts_list(cuts_list: List[str]) -> str:        assert cuts_list.__getattribute__('__iter__')        return " && ".join(cuts_list)    def generate(self, target: str = '') -> str:        assert CutsManager._current_cuts_dict is not None        del self.cuts        for key, value in CutsManager._current_cuts_dict.items():            if key == target:                continue            if isinstance(value[0], (int, float, bool)):                geq_str = str(f"{key} >= {value[0]}")                self.cuts = geq_str            if isinstance(value[1], (int, float, bool)):                leq_str = str(f"{key} <= {value[1]}")                self.cuts = leq_str        return self.__merge_cuts_list(self.cuts)class ConditionManager(CutsManager):    def __init__(self, dict_like: Dict[str, List[float]]):        super().__init__()        self.init(dict_like)    def generate(self, target: str = '') -> str:        assert CutsManager._current_cuts_dict is not None        del self.cuts        for key, value in CutsManager._current_cuts_dict.items():            if key == target: continue            if isinstance(value[0], (int, float, bool)):                geq_str = str(f"{key} >= {value[0]}")                self.cuts = geq_str            if isinstance(value[1], (int, float, bool)):                leq_str = str(f"{key} <= {value[1]}")                self.cuts = leq_str        return self._merge_conditions(self.cuts)    @staticmethod    def _merge_conditions(condition_list: List[str]) -> str:        """        Given a list of conditions, this method merges them using logical AND operator.        """        return " && ".join(condition_list)if __name__ == '__main__':    example_cuts_dict = {        "mbc_bs": [5.2, 5.6],        "de_bs": [-0.25, 0.25],        "eg1_d": [0.1, None]    }    test_obj = CutsManager()    test_obj.init(example_cuts_dict)    print(test_obj)    res_cuts = test_obj.generate("de_bs")    print(res_cuts, "\n")    print(test_obj.cuts)